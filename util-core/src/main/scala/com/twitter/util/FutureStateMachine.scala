package com.twitter.util

import com.twitter.util.Promise
import com.twitter.util.Future
import com.twitter.util.Return
import com.twitter.util.Throw

import java.util.Objects

import scala.concurrent.{ExecutionContext}
import scala.util.Success
import scala.util.Failure

/** The base class for state machines generated by the `scala.async.Async.async` macro.
  *  Not intended to be directly extended in user-written code.
  */
abstract class FutureStateMachine()
    extends Function1[scala.util.Try[AnyRef], Unit] {

  type F = com.twitter.util.Future[AnyRef]
  type R = scala.util.Try[AnyRef]

  private[this] val result$async: Promise[AnyRef] = Promise[AnyRef]();
  private[this] var state$async: Int = 0

  /** Retrieve the current value of the state variable */
  protected def state: Int = state$async

  /** Assign `i` to the state variable */
  protected def state_=(s: Int): Unit = state$async = s

  /** Complete the state machine with the given failure. */
  // scala-async accidentally started catching NonFatal exceptions in:
  //  https://github.com/scala/scala-async/commit/e3ff0382ae4e015fc69da8335450718951714982#diff-136ab0b6ecaee5d240cd109e2b17ccb2R411
  // This follows the new behaviour but should we fix the regression?
  protected def completeFailure(t: Throwable): Unit = {
    result$async.update(Throw(t))
  }

  /** Complete the state machine with the given value. */
  protected def completeSuccess(value: AnyRef): Unit = {
    result$async.update(Return(value))
  }

  /** Register the state machine as a completion callback of the given future. */
  protected def onComplete(f: F): Unit = {
    f.respond(t => this(t.asScala))
  }

  /** Extract the result of the given future if it is complete, or `null` if it is incomplete. */
  protected def getCompleted(f: F): R = {
    if (f.isDefined) {
      f.poll.get.asScala
    } else {
      null
    }
  }

  /**
    * Extract the success value of the given future. If the state machine detects a failure it may
    * complete the async block and return `this` as a sentinel value to indicate that the caller
    * (the state machine dispatch loop) should immediately exit.
    */
  protected def tryGet(tr: R): AnyRef =
    tr match {
      case Success(value) =>
        value.asInstanceOf[AnyRef]
      case Failure(throwable) =>
        completeFailure(throwable)
        this // sentinel value to indicate the dispatch loop should exit.
    }

  def start[T](): Future[T] = {
    // This cast is safe because we know that `def apply` does not consult its argument when `state == 0`.
    Future.Unit.asInstanceOf[Future[AnyRef]].respond(t => this(t.asScala))
    result$async.asInstanceOf[Future[T]]
  }
}
